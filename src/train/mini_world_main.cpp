// Mini-World training & validation runner
// - Reads .seq dataset generated by examples/mini-world/generator
// - Loads labels from labels/labels_counts.csv (per-clip constant count)
// - Splits into train/validation
// - Trains via Trainer/TrainingConfig
// - Validates and prints accuracy / confusion matrix

#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <map>
#include <unordered_map>
#include <algorithm>
#include <random>
#include <cctype>
#include <cstdio>
#include <regex>
#include <iomanip>

#include "../arch/glia.h"
#include "../arch/neuron.h"
#include "../arch/input_sequence.h"
#include "trainer.h"
#include "training_config.h"

struct MWConfig {
    std::string net_path;
    std::string data_root;       // folder containing seq/, labels/
    float train_fraction = 0.8f; // 0..1
    int max_class = 4;           // classes 0..max_class

    // Detector / episode timing
    int warmup = 20;
    int window = 80;
    float det_alpha = 0.05f;
    float det_threshold = 0.01f;
    std::string det_default_id; // e.g., "O0"; empty = abstain

    // Training
    bool train = true;
    int epochs = 10;
    int batch = 4;
    bool shuffle = true;
    unsigned int seed = 123456u;
    float lr = 0.01f;
    float lambda_ = 0.95f;
    float weight_decay = 0.0001f;
    float margin_delta = 0.05f;
    std::string reward_mode = "softplus_margin"; // see Trainer
    std::string update_gating = "none";         // none|winner_only|target_only
    float reward_gain = 1.0f;
    float reward_min = -1.0f;
    float reward_max = 1.0f;
    float reward_pos = 1.2f;
    float reward_neg = -0.8f;
    float r_target = 0.05f;
    float rate_alpha = 0.05f;
    bool  elig_post_use_rate = true;
    bool  no_update_if_satisfied = true;
    bool  use_advantage_baseline = true;
    float baseline_beta = 0.1f;
    float weight_clip = 0.0f; // 0 disables

    // Optional outputs
    std::string save_net;            // path to save trained net
    std::string train_metrics_json;  // per-epoch metrics JSON
};

// --- tiny helpers to read config JSON (regex-based, flat keys + nested detector)
static std::string read_file_all(const std::string &path) {
    std::ifstream f(path.c_str(), std::ios::in | std::ios::binary);
    if (!f.is_open()) return std::string();
    std::ostringstream ss; ss << f.rdbuf();
    return ss.str();
}
static bool extract_string_kv(const std::string &s, const std::string &key, std::string &out) {
    std::regex rgx(std::string("\"") + key + "\"\\s*:\\s*\"([^\"]*)\"");
    std::smatch m; if (std::regex_search(s, m, rgx)) { out = m[1]; return true; }
    return false;
}
static bool extract_float_kv(const std::string &s, const std::string &key, float &out) {
    std::regex rgx(std::string("\"") + key + "\"\\s*:\\s*([-+]?([0-9]*\\.[0-9]+|[0-9]+)([eE][-+]?[0-9]+)?)");
    std::smatch m; if (std::regex_search(s, m, rgx)) { out = std::strtof(m[1].str().c_str(), nullptr); return true; }
    return false;
}
static bool extract_int_kv(const std::string &s, const std::string &key, int &out) {
    std::regex rgx(std::string("\"") + key + "\"\\s*:\\s*([-+]?[0-9]+)");
    std::smatch m; if (std::regex_search(s, m, rgx)) { out = std::atoi(m[1].str().c_str()); return true; }
    return false;
}
static bool extract_uint_kv(const std::string &s, const std::string &key, unsigned int &out) {
    std::regex rgx(std::string("\"") + key + "\"\\s*:\\s*([0-9]+)");
    std::smatch m; if (std::regex_search(s, m, rgx)) { out = static_cast<unsigned int>(std::strtoul(m[1].str().c_str(), nullptr, 10)); return true; }
    return false;
}
static bool extract_bool_kv(const std::string &s, const std::string &key, bool &out) {
    std::regex rgx(std::string("\"") + key + "\"\\s*:\\s*(true|false|0|1)");
    std::smatch m; if (std::regex_search(s, m, rgx)) { std::string v = m[1]; out = (v == "true" || v == "1"); return true; }
    return false;
}

static bool parse_config_json(const std::string &path, MWConfig &cfg) {
    std::string s = read_file_all(path);
    if (s.empty()) { std::cerr << "Could not read config: " << path << "\n"; return false; }
    extract_string_kv(s, "net_path", cfg.net_path);
    extract_string_kv(s, "data_root", cfg.data_root);
    extract_float_kv(s,  "train_fraction", cfg.train_fraction);
    extract_int_kv(s,    "max_class", cfg.max_class);

    extract_int_kv(s, "warmup", cfg.warmup);
    extract_int_kv(s, "window", cfg.window);
    extract_float_kv(s, "alpha", cfg.det_alpha);
    extract_float_kv(s, "threshold", cfg.det_threshold);
    extract_string_kv(s, "default", cfg.det_default_id);

    extract_bool_kv(s,   "train", cfg.train);
    extract_int_kv(s,    "epochs", cfg.epochs);
    extract_int_kv(s,    "batch", cfg.batch);
    { bool b; if (extract_bool_kv(s, "shuffle", b)) cfg.shuffle = b; }
    extract_uint_kv(s,   "seed", cfg.seed);
    extract_float_kv(s,  "lr", cfg.lr);
    extract_float_kv(s,  "lambda", cfg.lambda_);
    extract_float_kv(s,  "weight_decay", cfg.weight_decay);
    extract_float_kv(s,  "margin", cfg.margin_delta);
    extract_string_kv(s, "reward_mode", cfg.reward_mode);
    extract_string_kv(s, "update_gating", cfg.update_gating);
    extract_float_kv(s,  "reward_gain", cfg.reward_gain);
    extract_float_kv(s,  "reward_min", cfg.reward_min);
    extract_float_kv(s,  "reward_max", cfg.reward_max);
    extract_float_kv(s,  "reward_pos", cfg.reward_pos);
    extract_float_kv(s,  "reward_neg", cfg.reward_neg);
    extract_float_kv(s,  "r_target", cfg.r_target);
    extract_float_kv(s,  "rate_alpha", cfg.rate_alpha);
    { bool b; if (extract_bool_kv(s, "elig_post_use_rate", b)) cfg.elig_post_use_rate = b; }
    { bool b; if (extract_bool_kv(s, "no_update_if_satisfied", b)) cfg.no_update_if_satisfied = b; }
    { bool b; if (extract_bool_kv(s, "use_advantage_baseline", b)) cfg.use_advantage_baseline = b; }
    extract_float_kv(s,  "baseline_beta", cfg.baseline_beta);
    extract_float_kv(s,  "weight_clip", cfg.weight_clip);

    extract_string_kv(s, "save_net", cfg.save_net);
    extract_string_kv(s, "train_metrics_json", cfg.train_metrics_json);

    // Nested detector object support
    size_t pos = s.find("\"detector\"");
    if (pos != std::string::npos) {
        size_t brace = s.find('{', pos);
        if (brace != std::string::npos) {
            int depth = 1; size_t i = brace + 1;
            for (; i < s.size() && depth > 0; ++i) { if (s[i] == '{') depth++; else if (s[i] == '}') depth--; }
            if (depth == 0) {
                std::string sub = s.substr(brace, i - brace);
                extract_float_kv(sub,  "alpha", cfg.det_alpha);
                extract_float_kv(sub,  "threshold", cfg.det_threshold);
                extract_string_kv(sub, "default_id", cfg.det_default_id);
            }
        }
    }
    return true;
}

// --- labels loader (clip_id,tick,true_count) -> map[clip_id] = true_count (first seen per clip)
static bool load_labels(const std::string &labels_csv_path, std::map<int,int> &out) {
    std::ifstream f(labels_csv_path.c_str());
    if (!f.is_open()) { std::cerr << "Could not open labels CSV: " << labels_csv_path << "\n"; return false; }
    std::string line; int line_no = 0;
    while (std::getline(f, line)) {
        line_no++;
        if (line_no == 1) continue; // header
        if (line.empty()) continue;
        std::istringstream iss(line);
        std::string a,b,c;
        if (!std::getline(iss, a, ',')) continue;
        if (!std::getline(iss, b, ',')) continue;
        if (!std::getline(iss, c, ',')) continue;
        int clip_id = std::atoi(a.c_str());
        int tick    = std::atoi(b.c_str()); (void)tick;
        int count   = std::atoi(c.c_str());
        if (out.find(clip_id) == out.end()) out[clip_id] = count;
    }
    return true;
}

static std::string make_seq_path(const std::string &root, int clip_id) {
    char buf[64]; std::snprintf(buf, sizeof(buf), "clip_%05d.seq", clip_id);
    std::string p = root; if (!p.empty() && (p.back() != '/' && p.back() != '\\')) p += "/"; p += buf;
    return p;
}

static int parse_output_index(const std::string &id) {
    if (id.size() >= 2 && (id[0] == 'O' || id[0] == 'o')) return std::atoi(id.c_str() + 1);
    return -1;
}

static void write_metrics_json(const std::string &path,
                               const std::vector<double> &acc,
                               const std::vector<double> &margin,
                               int epochs)
{
    std::ofstream jf(path.c_str(), std::ios::out | std::ios::trunc);
    if (!jf.is_open()) return;
    jf << "{\n";
    jf << "  \"epochs\": " << epochs << ",\n";
    jf << "  \"accuracy\": ["; for (size_t i=0;i<acc.size();++i){ jf << acc[i]; if (i+1<acc.size()) jf << ","; } jf << "],\n";
    jf << "  \"margin\": ["; for (size_t i=0;i<margin.size();++i){ jf << margin[i]; if (i+1<margin.size()) jf << ","; } jf << "]\n";
    jf << "}\n";
}

int main(int argc, char** argv) {
    if (argc < 3 || std::string(argv[1]) != std::string("--config")) {
        std::cout << "Usage: " << argv[0] << " --config <path.json>\n";
        return 1;
    }

    MWConfig args;
    if (!parse_config_json(argv[2], args)) return 2;
    if (args.net_path.empty() || args.data_root.empty()) {
        std::cerr << "Config must set net_path and data_root\n"; return 3;
    }

    // Load labels (one label per clip)
    std::string labels_csv = args.data_root + (args.data_root.back()=='/'||args.data_root.back()=='\\' ? std::string("") : std::string("/")) + "labels/labels_counts.csv";
    std::map<int,int> labels;
    if (!load_labels(labels_csv, labels)) return 4;

    // Build dataset using existing seq files for labeled clips
    std::vector<std::pair<int, Trainer::EpisodeData>> samples; samples.reserve(labels.size());
    std::string seq_dir = args.data_root + (args.data_root.back()=='/'||args.data_root.back()=='\\' ? std::string("") : std::string("/")) + "seq";
    for (const auto &kv : labels) {
        int clip_id = kv.first;
        int count = kv.second; if (count < 0) count = 0; if (count > args.max_class) count = args.max_class;
        std::string seq_path = make_seq_path(seq_dir, clip_id);
        std::ifstream test(seq_path.c_str()); if (!test.is_open()) { continue; }
        test.close();
        InputSequence seq; if (!seq.loadFromFile(seq_path)) { std::cerr << "Failed to load seq: " << seq_path << "\n"; continue; }
        Trainer::EpisodeData ex; ex.seq = seq; ex.target_id = std::string("O") + std::to_string(count);
        samples.emplace_back(clip_id, ex);
    }
    if (samples.empty()) { std::cerr << "No dataset samples found under: " << args.data_root << "\n"; return 5; }

    // Shuffle by clip id order then shuffle with seed
    std::sort(samples.begin(), samples.end(), [](const auto &a, const auto &b){ return a.first < b.first; });
    std::mt19937 rng(args.seed);
    std::shuffle(samples.begin(), samples.end(), rng);

    size_t N = samples.size();
    size_t Ntrain = static_cast<size_t>(std::max(0.0f, std::min(1.0f, args.train_fraction)) * static_cast<float>(N));
    if (Ntrain == 0 || Ntrain >= N) Ntrain = (N > 1 ? N - 1 : N);

    std::vector<Trainer::EpisodeData> train_set; train_set.reserve(Ntrain);
    std::vector<Trainer::EpisodeData> val_set; val_set.reserve(N - Ntrain);
    for (size_t i = 0; i < N; ++i) {
        if (i < Ntrain) train_set.push_back(samples[i].second);
        else val_set.push_back(samples[i].second);
    }
    std::cout << "Dataset: total=" << N << "  train=" << train_set.size() << "  val=" << val_set.size() << "\n";

    // Build network
    Glia net; net.configureNetworkFromFile(args.net_path);

    // Configure training
    TrainingConfig cfg;
    cfg.warmup_ticks = args.warmup;
    cfg.decision_window = args.window;
    cfg.detector.alpha = args.det_alpha;
    cfg.detector.threshold = args.det_threshold;
    cfg.detector.default_id = args.det_default_id;
    cfg.lr = args.lr;
    cfg.elig_lambda = args.lambda_;
    cfg.weight_decay = args.weight_decay;
    cfg.margin_delta = args.margin_delta;
    cfg.reward_mode = args.reward_mode;
    cfg.update_gating = args.update_gating;
    cfg.reward_gain = args.reward_gain;
    cfg.reward_min = args.reward_min;
    cfg.reward_max = args.reward_max;
    cfg.reward_pos = args.reward_pos;
    cfg.reward_neg = args.reward_neg;
    cfg.r_target = args.r_target;
    cfg.rate_alpha = args.rate_alpha;
    cfg.elig_post_use_rate = args.elig_post_use_rate;
    cfg.no_update_if_satisfied = args.no_update_if_satisfied;
    cfg.use_advantage_baseline = args.use_advantage_baseline;
    cfg.baseline_beta = args.baseline_beta;
    cfg.weight_clip = args.weight_clip;
    cfg.batch_size = std::max(1, args.batch);
    cfg.shuffle = args.shuffle;
    cfg.verbose = true;
    cfg.log_every = 1;
    cfg.seed = args.seed;

    Trainer trainer(net);
    trainer.reseed(args.seed);

    if (args.train && args.epochs > 0) {
        trainer.trainEpoch(train_set, args.epochs, cfg);
        auto acc = trainer.getEpochAccHistory();
        auto margin = trainer.getEpochMarginHistory();
        if (!args.train_metrics_json.empty()) write_metrics_json(args.train_metrics_json, acc, margin, args.epochs);
    }

    // Save trained net if requested
    if (!args.save_net.empty()) {
        net.saveNetworkToFile(args.save_net);
    }

    // Validate
    if (!val_set.empty()) {
        size_t correct = 0; size_t total = 0;
        int K = args.max_class + 1;
        std::vector<std::vector<int>> cm(K, std::vector<int>(K, 0));
        for (const auto &ex : val_set) {
            EpisodeMetrics m = trainer.evaluate(const_cast<InputSequence&>(ex.seq), cfg);
            int yt = parse_output_index(ex.target_id);
            int yp = parse_output_index(m.winner_id);
            if (yt >= 0 && yt <= args.max_class && yp >= 0 && yp <= args.max_class) {
                cm[yt][yp] += 1;
                if (yt == yp) correct += 1;
            }
            total += 1;
        }
        double acc = (total == 0) ? 0.0 : (static_cast<double>(correct) / static_cast<double>(total));
        std::cout << "Validation: samples=" << total << "  accuracy=" << (acc * 100.0) << "%\n";
        std::cout << "Confusion (rows=true, cols=pred):\n";
        for (int r = 0; r < K; ++r) {
            std::cout << "  ";
            for (int c = 0; c < K; ++c) std::cout << std::setw(6) << cm[r][c];
            std::cout << "\n";
        }
    }

    return 0;
}

